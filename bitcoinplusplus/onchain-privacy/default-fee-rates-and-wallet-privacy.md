---
title: "Default Fee Rates and Wallet Privacy"
transcript_by: MomboteQ via review.btctranscripts.com
media: https://www.youtube.com/watch?v=R1rmT7ue1HA
tags: ["wallet","privacy","fees"]
speakers: ["Randy Naar"]
categories: ["conference"]
date: 2023-02-17
---

I'm going to make sure I can get all the threads in. Yeah, perfect. Oh, this is not working. All right, so my talk is on fee rates and wallet privacy. My name is Randy. I'm a software engineer at Blockstream. I typically work in applications for Liquid, but today I'll be talking about Bitcoin and how you might reduce your wallet privacy by using the default fee rates of your wallet. Before I get started, I wanted to go over some context about these fee rates. So a couple questions. What are transaction fees? Size versus virtual size, and why are fees important? So what are transaction fees? Transaction fees, they're the difference between a Bitcoin's transactions inputs and outputs, if you didn't know that. And the fee is pretty much equal to the total input amount minus the total output amount. Yeah, I know it shows up kind of small and that might be a problem for later slides. I hope it's still okay right now. Fees, they're implicit in a Bitcoin transaction and can be set to any arbitrary amount, assuming you have the funds to pay for it. Of course, fees are typically set to an amount proportional to the size of the transaction it's contained within. So, you know, if you have a big transaction, you typically pay more fees than a transaction that you paid, means like the size of your transaction. And Bitcoin transaction fees make the transaction more attractive for miners. It can get your transaction mined and therefore confirmed quicker. So, again, some more context for people who may not be familiar with fees that are actually paid out in a coinbase transaction. I know it's very hard to see, but I added a lot of these codes to the bits. If you're interested in any of these, you can scan the store code and it links you to the code. This happens to be in the Bitcoin core, which is supposed to. So size versus virtual size. During the SegWit software, a decision was made to modify the size of the transaction to discount the witness when computing your fee rates. Because the size used for fees does not represent the true number of bytes in the transaction, it's actually called the virtual size, which is why you might see X stats per V bite instead of X stats per byte. I had some reasoning behind this. It was by Christian Decker. He had something here. But, you know, you can't really see them. But it's pretty much some justification of why they wanted to discount the witnesses when computing the fees. And yeah. I could read a little bit about it here for Christian Decker's response. Witnesses do not need to be stored once they have been verified and can be discarded. This effectively reduces the size of the UTXO. It discounts, supposed to account for the reduced storage requirements and to encourage users to switch to cellular, benefiting the network as a whole. So that is a little brief side note about V size. So what I'm actually gonna get into today is wallet fingerprinting. If you're not into web dev and things like that, there's server fingerprinting, which is like figuring out what server software a specific web server is using. And Here, the concept is very similar. It's trying to figure out what wallet implementation a user's using based off their transactions. So hence, wallet fingerprinting. I actually had some inspiration for this. If you guys know, Andrew Chow, he had a talk, I guess, at Bitcoin hackathon that I went to, it's the previous Bitcoin++ and he kind of, this is the QR code for that link to the YouTube video and he also has a repo on github. Basically, so this all served as my inspiration. He did it on different metrics about how you can identify a wallet software implementation. So he had like, whether it uses anti-fee sniping with unlock time, you know, all these other things pretty much. And he did it between Bitcoin and Electrum. So I like that idea a lot, and I wanted to expand on that. So the wallets that I'm deciding to use are the blue wallet, the green wallet, and the Wasabi wallet. And the question that I have to answer before I can see whether I can identify someone's wallet, depending on their transactions, is can wallets vary in the default fee amount? And the answer is yes. So for the same transaction, you can have varying transaction fee amounts, depending on the wallet that you're using. So why are the fee rates different? Naively, you might assume, well, they're using different fee sources. And they do. Blue uses Electrum. Green uses the Green Server. Wasabi uses blockchain by default. They actually call out the blockchain API. But that's not the main reason that these fees are different. They actually do different algorithms. So there's a fee algorithm for Blue. And Here, I can read what I wrote here. The bluewallet uses a fee algorithm that multiplies the fee rate for each category of fee rate, so fast, medium, and slow, with the fee rate calculated from one block of mempool, and divides it by the fee rate for one block calculated by Electrum. And that's like a lot of jargon I'm gonna show you, a code snippet that hopefully you can see a little bit from that. If the fee rate for the transaction is amountable, it's extremely low. While the fee rate coming from electrum is high, Blue basically tries to account for that by discounting the fee rate. And this is a simplification of what happens. And this is the actual code snippet. Again, I know this is very, very hard to see. I was expecting this to be a little bit bigger so you could scan this for a code and see how it's actually done. And you know, what does it mean to get one block of the mempool? You actually, they have this little algorithm that you might be able to see. They're trying to calculate the size of things in the transaction and see if it could fit in like the next block, for example. So again, I added this code last minute because I was like, maybe people might have questions and this is the QR code. And this is all open source. I've only done analysis of open source code. So you could go in the bluewallet repo and look at this for yourself. So if you have rooms for green, green is a little bit different because they use something called the green server, so I can't really do much of that, I'm not going to leak what they have, but from an open source perspective you can see that they make a call to the green server. They use a protocol called wham. Yeah, there's not much analysis I can do there from an open source perspective, because a lot of it is in behind the green server source code, which is not open source. And then we can look at Wasabi's fee rate algorithm. Wasabi, you can source them from your Bitcoin Core node as well. They are very flexible to look at the source code. But one of the fee rate providers is the Blockstream fee rate provider. And basically what they do is they hire them samples from Blockstream for fee rates, and then it interpolates the values between the sample fee rates for more granularity. I'm just asking a bit more detail about that. So it's asking Blockstream and saying, well, give me a feed for a five block target? What is it asking Blockstream exactly? Yeah, so Blockstream has an endpoint for a few minutes, and it'll give you a bunch of different, you know, block. But How is it? It doesn't just give you one number I'm guessing, does it? The API is letting you choose? No, it gives predefined block confirmation. Yeah, so you can choose a block target, like 10 blocks. Right. What's my fear is getting the next 10 blocks, yeah? Right, but The API they call is general, and it's a JSON that includes a lot of different desired target blocks. So what Wasabi does is they pick from a few of them. They don't use all of them. The options you have are for the block target as a number. Is that the only one, or is there like a fast, slow, medium, something like that? No, yeah, there's no fast, slow, medium. It's just the number of blocks. Right. And you're saying, well, so I'll be choosing multiple different numbers from that list of possibilities. Right. Three blocks, five blocks, ten blocks, twenty blocks. I see, right. And then they interpolate, yeah, yeah, they interpolate between them. They interpolate between those values? Yeah, they have like this, here let me just switch this for a second. Oh, so they put all those on a graph and they just say, oh, we want, they choose something between those numbers, is that right? Oh, right, yeah, there's like algorithms for this, they can interpolate between two different numbers. So if you look at the source code, I don't want to dive into the source code exactly, but you can kind of see they do this interpolate, pchip sorted, right? And you can look at the libraries they use and everything. Again, do the chart code here. This is specifically for this method, get Satoshi per byte. They actually do the sampling thing twice. But I just, it's very hard to capture the context of what these models are doing because they span sometimes multiple methods and I don't want to have too much source code on my slides. So as you see, it's kind of hard to read through. But yeah, the basics of what Wasabi is doing is they have this interpolation for the feed algorithm. And again, I- how do they do? Recommend, or if you want to get any of these links afterwards as well, you can flag me down and like, you know, I'll be happy to. So if- if they're interpolating, for example, they- they- they get numbers of 3, 5, 10 and they interpolate 7, let's say. Right. But surely the most important thing is what is the user doing? Because if all of that is in from the user and the user never even chooses a fee, then you've got an issue with privacy and them choosing one particular thing, maybe. Is the user choosing a number? They do not. There is a default fee rate for all these wallets. In general, I think it's like a bad UX if a wallet forces you to choose a fee rate because as a regular user, you might be like, you know, we're like, choose. But most wallets nowadays seem to be, the most common thing is they're giving you options in words, low, fast, medium, slow. That's the most common thing I'm seeing. Yeah, for example, going back to Blue, they do have fast medium scale, but the default is fast. It's good enough for people to want to use. Wasabi, same thing, they have a default fee rate. If you'd like to switch it, they actually have a chart that pops up and you can move the slider to say the desired time that you'd like your transaction to get in and out of and into the blockchain. So yeah, that's the experience of Wasabi. So I did some experiments, I was curious to see if I could identify anything within how my wallets actually make their transactions. And there's a little visualization on there. This is for a block, the distribution of the fees, or fee rates. So this is one test transaction. And, you know, this transaction I paid about 14.5 sats per vbyte. And I wanted to see if you could just off one transaction in a given period of time for each of these walls reporting the default view rate, which one it might be. And yeah, so blue was reporting 14 sats per view byte, green is 14.19, and we'll solve these 29 sats per view byte. What actually ended up happening was this became 4.5 cents per debit and this came from Green. So there is a slight discrepancy within these fee rates and I'm thinking maybe I might have like, sampled it wrong where green was doing something extra. And I will show that some of the fees that are provided, well specifically for blue wallet, they are higher than they need to be because of a shortcut they took and then a calculation of transactions in the size. This is another test transaction, this is a little bit clearer. You have one fee rate of 12 cents per vbite for blue, you have another one that's 14.2 for green, and then 15 for Wasabi, so a little bit more spread out. And the fee rate for this actual transaction that was made is 12.3. And if you can see these fee rates, blue had a 12 cent per vbyte, and this actually did come from blue. Why is this .3 there? There's a reason for that, and I'll go into that in these next slides. So I want to talk about any other fee-related wallet tells. Going back to what I said, there is a wallet tell from Blue, and this is a shortcut that they take for their calculation. This is the shortcut that they take for their calculation. And this is the shortcut that they take. Pretty much, when you calculate a transaction size, you look at the amount of bytes it takes for an input. And when you spend from a regular transaction made with a witness, it uses this thing, transaction input public key hash, and they have a constant that's set for it. And Why is that bad? Because there is some variance that can happen in when you create an input with a witness, for a regular witness public key hash, and that is your signature can change. There's some factors on how long your signature is. There's these like two values, like R and S, and you can have a high S value or a high R value, and if you have both of them high, then that is like kind of bad because you add two extra bytes that you don't need. Bitcoin core kind of standardizes it and they try and use low s and low r, but some models don't really care. Blue is one of them, they don't enforce low s and low r. In the source code it's easy enough, like if they wanted to enable it, but for R it's a little bit harder, you have to do something called low R grinding, which is like this, somewhat more computationally expensive. So, Blue, they just assume that you will be using like high R and high S, and now another extra byte in the calculation. So sometimes when you insert an input for your transaction, Blue pretty much overestimates an extra three bytes you might be paying for an extra three bytes that you didn't actually use. And I guess that's one of the tells from Blue Wallet. As far as I can tell, these other wallets, they don't have this problem. They kind of estimate the virtual size a little bit more accurately. So Green is a wallet that uses another library called the GDK. And GDK uses another library called Blue wallet to calculate the virtual size. So I included a snippet here. And they're more accurate. They don't kind of make those shortcuts. And same thing for Wasabi. They're also more accurate because they use something called NBitcoin, which is kind of a pretty sophisticated Bitcoin library for C-sharp. And yeah, so again, here's these code snippets and so on. So, the talk's pretty much over. The conclusion is, wall-fingerprinting can definitely be a threat to your on-chain privacy via the analysis of fee rates, but whether that trade-off of privacy for convenience is worth it, up to you. That's pretty much what I can say. Some users may not care about this, but I think at the very least everyone should be aware that this is a leakage of information. And yeah, so thank you. That's all I have for this talk. (Applause) Does it make sense to, for example, try to be like Bitcoin Core or be like Electrum, for example? Yeah, we were having some discussions where you could either hide in plain sight, right, where you could try and share a fee rate with whatever is the most popular being used, Or you could have some kind of variance. You could put some randomization in it. And that kind of helps obscure which wallet that you can come from. But yeah, so that's a common thing that people try and do. Let's try and standardize and do whatever Bitcoin Core does. In terms of having a low s in your signature, using low R grinding for all of your transactions, that helps standardize things and make your fee rates look more uniform, right? And won't have your wallet stand out and boost more, for example. Yeah, have you looked at peering then along with things like say in-lock time and sequence to kind of confirm that assumption about certain wallets? Because I looked at this very briefly but they seem to be two fields that were also vulnerable to fingerprinting. Yeah, so... And now you can add what the three together would like really confirm, you know... Yeah, putting all this together, you can definitely create something pretty strong for a lot of fingerprinting. So, again, this is back in the intro, but Andrew Chow had our presentation and he did use things for like face typing and all that. And I recommend watching it. His presentation, he also has some sample code and rust on how you might be able to do that. So, but yes, you can combine it with more things. And did someone else have a question? Yeah. Can you go over what bad things could happen if someone else finds out what type of wallet you're using? Yeah, depending on your wallet implementation, maybe there's like... Like a vulnerability that they know... Yeah, or even like a behavior that someone can game, right? Or let's say Blu-ray, or I'm sorry, Blue uses the mempool to help calculate their transaction rates, right? How about if I fill the mempool with a bunch of like, I don't know, high end transactions to screw one person over, right? Or something similar, right? So depending on what each wallet does, I can game them, if I know they're using a certain wallet, I can make you pay more fees or stuff like that. That's it. That's true, but also I think the simplest answer to why this is a problem is, just think of the simplest possible trend of actually you're spending some money, giving some, you've got change output. Now, chain analysis might be able to figure out the change output, but often they can't figure out just the change in the payment. But if it's obviously coming from the same wallet as the input, then that's obviously the change. All right, So it's one way in which chain analysis is made a lot easier is if they contract through, well it's the same wallet going through all those outputs. All right, yeah, so that would be, yeah, something else. All right. Yeah, any other questions? No, all right, thanks. Thank you. All right, thanks. Applause
